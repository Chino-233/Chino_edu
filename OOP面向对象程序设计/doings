LAB6 - 游戏： 点和框
游戏简介
有没有过几分钟的空闲时间？我们都有过。在孩提时代的许多这样的时刻，你很可能会决定玩一个游戏。在本实验室中，你将编写一个命令行版本的游戏。
游戏规则
点和框》是一款双人游戏，在大小可变的点网格上进行。在本作业中，游戏板是一个 4x4 的点网格，两个玩家用两个符号表示： 1 和 2。
游戏规则如下：
玩家 1 总是先出牌。
，每个玩家轮流在两个相邻的点之间画一条水平线或垂直线。
 玩家不能在已经被一条线连接起来的两个点之间画线。
如果玩家画完了一个（或多个）方框的第四面，则在方框中写下自己的数字（1 或 2），并可以再画一条线。
，当所有相邻的点都用横线或竖线连接起来时，游戏结束。
，游戏结束时方格数最多的玩家获胜。
游戏棋盘
游戏棋盘是一个由点组成的 4x4 网格，点用 ASCII 字符 “*”（星号，ASCII 码 x002A）表示。垂直线用 ASCII 字符“|”（管道，ASCII 码 x007C）表示，水平线用 ASCII 字符“-”（连字符，ASCII 码 x002D）表示。网格的行用数字 0 至 6 表示，网格的列用字母 A 至 G 表示：
    ABCDEFG
  0 * * * *
  1        
  2 * * * *
  3        
  4 * * * *
  5        
  6 * * * *
移动是由指定相邻两个点之间空格的两个字符输入对指定的。第一个字符应为大写字母（A-G），指定所需的列，第二个字符应为数字（0-6），指定所需的行。例如，输入 A1 将产生以下棋盘：
    ABCDEFG
    0123456
  0 * * * *
  1 |      
  2 * * * *
  3        
  4 * * * *
  5        
  6 * * * *
如果下一步是 D4，棋盘现在看起来如下：
    ABCDEFG
  0 * * * *
  1 |      
  2 * * * *
  3        
  4 * *-* *
  5        
  6 * * * *
游戏棋盘的初始数据结构通过 7 个 .STRINGZ 伪操作存储在内存中，每行一个。在程序执行过程中，我们将修改这些内存位置的内容，以反映每位棋手的棋步。
算法
为了设计一个 “点和框 ”游戏或任何其他软件项目，我们必须将问题分解成小块。为此，我们绘制了以下 “圆点和方框 ”流程图。

您将以该流程图为基础设计程序。您必须实现的模块以粗体显示。
您的工作
在这里和这里可以找到正在进行的游戏的输入/输出示例。以下启动代码提供了 “点和框 ”游戏的总体框架，以及我们为您提供的一些子程序。你的任务是通过编写以下子程序来完成 “圆点和方框 ”游戏：
DISPLAY_PROMPT
该子程序提示当前玩家输入棋子。当前玩家是 1 还是 2，由标有 CURRENT_PLAYER 的内存位置的内容决定，该位置初始设置为 1。
Memory[CURRENT_PLAYER] = 1 表示棋手 1
                         玩家 2 为 2
根据当前玩家的情况，该子程序应打印以下信息之一
玩家 1，请输入棋步（或 'Q' 表示退出）：
棋手 2，请输入棋步（或输入 “Q ”退出）：  
IS_INPUT_VALID
该子程序检查棋手的棋步是否有效。
调用该子程序时，R0 包含玩家键入的第二个字符（行）的 ASCII 码，R1 包含用户键入的第一个字符（列）的 ASCII 码。该子程序
 检查 R0 中的字符是否介于 “0 ”和 “6 ”之间。如果不是，则输入无效。
 检查 R1 中的字符是否介于 “A ”和 “G ”之间。如果不是，则输入无效。
 检查 (R0, R1) 指定的（行、列）对是否与游戏棋盘中的'*'（星号）相对应。如果是，则输入无效。
 其他一些无效情况 ...
如果输入有效，则在 R3 中返回值 0（零）。
如果输入无效，则在 R3 中返回值-1。
移动
调用该子程序时，R0 包含行号的 ASCII 码（'0'-'6'），R1 包含列字母的 ASCII 码（'A'-'G'）。该子程序应
 将行号的 ASCII 码转换为数字的二进制表示（0-6），并将结果返回 R0。
 将列字母的 ASCII 码转换为介于 0 和 6 之间的二进制数（其中'A'对应 0，'B'对应 1，...，'G'对应 6）。'G'对应 6），并将结果返回 R1。
例如，如果调用子程序时 R0 包含 “5 ”的 ASCII 码（x0035），R1 包含 “C ”的 ASCII 码（x0043），那么子程序返回时 R0 应包含值 5，R1 应包含值 2。
IS_OCCUPIED
调用该子程序时，R0 包含一个行号（0-6，您之前从 TRANSLATE_MOVE 中提供的），R1 包含一个列号（0-6，也是从 TRANSLATE_MOVE 中提供的）。您应该检查 (行、列) 对对应的棋盘位置，看看该位置是否已被占用。
，如果位置已被占用，则应在 R3 中返回值-1。
，如果位置未被占用，则应在 R3 中返回值 0（零）。
子程序返回时，R0 和 R1 中的值必须与调用子程序时的值完全相同。
获取地址
该子程序用于确定由（行、列）对指定的位置在内存中的地址。调用该子程序时，R0 包含行号（0-6），R1 包含列号（0-6）。子程序返回时，R3 应包含游戏棋盘数据结构中与该行、列相对应的地址。
注意：每一行的字符串在内存中会占用 8 个连续位置（字符串中的 7 个字符 + 1 个 NULL 结束符）。在汇编文件中，我们按顺序排列了电路板的 7 个字符串，这意味着每行相隔 8 个内存位置。假设 R5 包含第 0 行字符串的起始地址，如果在 R5 中添加 24（即 8*3），那么 R5 中的地址是多少？如果在 R5 中加上 4，R5 中的值有什么意义？您可能需要从许多其他子程序中调用该子程序。
移动
该子程序通过在正确位置写入“-”（连字符，ASCII 码 x002D）或“|”（管道，ASCII 码 x007C），将棋手的移动应用到棋盘上。
调用此子程序时，R0 包含 TRANSLATE_MOVE 提供的行号（0-6），R1 包含列号（0-6）。行、列）对指定的位置保证是空闲的（如果 IS_OCCUPIED 写得正确）。该子程序应
 根据（行、列）对，确定要写入的字符是“-”还是“|”。
 将字符写入游戏棋盘数据结构中的正确位置。
注意：您不需要对（行、列）对进行错误检查；IS_INPUT_VALID 已经完成了错误检查。子程序返回时 R0 和 R1 中的值必须与调用子程序时的值完全相同。
填充方框
该子程序将当前玩家的号码写入一个已完成的方框中，并将从 BOXES_COMPLETED 子程序（我们已提供）中调用。
调用该子程序时，R0 包含行号（0-6），R1 包含列号（0-6）。行、列）对指定了刚刚完成的方框的中心位置。该子程序应
 确定哪个玩家完成了方格。
 写入已完成方格中心的玩家编号的 ASCII 码。
注意：子程序返回时，R0 和 R1 中的值必须与调用子程序时的值完全相同。
更新状态
如有必要，该子程序将更新比分和球员。调用此子程序时，R0 包含当前玩家刚刚完成的方格数。该值由 BOXES_COMPLETED 子程序（我们已提供）提供，可能是 0、1 或 2。该子程序应
 更新包含当前玩家分数的内存位置，以反映他刚刚完成的方格数。
o 玩家 1 的分数存储在标有 SCORE_PLAYER_ONE 的内存位置。
o 玩家 2 的分数存储在标有 SCORE_PLAYER_TWO 的内存位置。
 更新内存位置 CURRENT_PLAYER 的内容，以反映下一轮轮到哪个玩家。请记住，如果一名玩家刚刚完成了一个方格，他就可以再次进行游戏。
IS_GAME_OVER
该子程序决定游戏是否结束。当游戏棋盘上的所有方格都已完成时，游戏结束。
如果游戏结束，则应 
确定获胜者。
打印以下信息之一
游戏结束。玩家 1 是赢家！
游戏结束。玩家 2 获胜！
在 R3 中返回值 0（零）。
，如果游戏尚未结束，则应在 R3 中返回值-1。
提示：游戏结束后，两名玩家的总得分是多少？

我们为您提供了以下子程序：
DISPLAY_BOARD
该子程序将游戏棋盘和两位玩家的当前得分打印到屏幕上。
完成方格
该子程序用于确定这步棋中是否完成了一个（或两个）棋盒。
调用此子程序时，R0 和 R1 分别包含一个行号（0-6）和一个列号（0-6），与刚刚应用到棋盘上的棋步相对应。对于每个已完成的方格，FILL_BOX 会被调用，调用的（行、列）对指定了已完成方格的中心点。
注意：您必须为 BOXES_COMPLE 正确执行 FILL_BOX
注意：必须正确执行 FILL_BOX，BOXES_COMPLETED 才能正常工作。完成的方框数（0、1 或 2）将在 R3 中返回。
提交
请提交 LAB5_ID.asm 文件和报告。
